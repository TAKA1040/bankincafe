エラーの核心
Type error: Element implicitly has an 'any' type because expression of type '` ${string}_${string} `'
can't be used to index type '...'


該当箇所:

return priceBookMap[`${target}_${action}`] || null


TypeScriptが「${target}_${action}」という文字列を、priceBookMap のキーとして保証できない、と怒ってる。
→ つまり 型定義と実際のアクセス方法が噛み合ってない。

解決の方向性（3パターン）
① Record<string, 型> にしてしまう（安全寄り）

priceBookMap が「任意の文字列キーを持つマップ」であるなら、型をこう修正：

// 例: 値が string の場合
const priceBookMap: Record<string, string> = { ... }

// 例: 値がオブジェクトなら
const priceBookMap: Record<string, PriceBookItem> = { ... }

② キーの型を絞る

もし priceBookMap のキーが「${target}_${action}」形式だけに限られるなら、型をUnionで表す:

type PriceBookKey = `${string}_${string}`
const priceBookMap: Record<PriceBookKey, PriceBookItem> = { ... }

③ キャストで逃げる（暫定）

まず動かすだけならキャスト：

return (priceBookMap as Record<string, any>)[`${target}_${action}`] || null


ただしこれは型安全性を捨てるので、最終的には①や②に持っていくのがおすすめ。

推奨手順

priceBookMap の定義場所を確認

どこで型を宣言している？（useState / useMemo / props など）

その上で、

ざっくり動かしたい → ③

型安全を担保したい → ① か ②

👉 たかまる、この priceBookMap って「何をキーにして」「どんな値を持たせる」想定？
（例: "target_action" → 単価情報 みたいな感じ？）
そこが分かれば、①と②どっちが正解か切り分けられるよ。


ChatGPTが見た感じこういう意見も言ってるので参考にしてみて。